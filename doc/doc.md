# I. 简介
LCE是一个机制简单的RTS游戏.

# II. 游戏界面
游戏界面分为左上小屏幕, 右上小屏幕, 左下小屏幕和右下小屏幕以及中央大屏幕5部分.
左上是小地图, 左下是飞船信息, 右下是战斗通知.
一开始中央大屏为空白. 点击小地图或者通知或者飞船信息会将其投送到大屏幕上. 但是其原位依然显示原来的内容. 
因为点击小屏幕只会改变中央大屏幕的情况, 所以无法直接与小屏幕交互, 必须先点击一下点开之后, 在大屏幕进行操作.
## II-1. 地图
### 大屏显示
飞船以蓝色或红色的小三角形来表示, 蓝色表示己方, 红色表示敌方. 一条淡淡的灰色线标明飞船的航向. 我方飞船的位置必定是实时的, 即地图上飞船的位置就是其实时坐标. 但是敌方飞船的位置是延迟的, 要落后于当前时间敌方飞船实际处于的位置. 一个白色的框会标明算上延迟之后, 敌方飞船的预测位置.
当你的画面缩放到一定程度, 会显示出飞船的名字.
敌方飞船从视野中消失后, 会在地图上留下一个空心红色圆.
点击己方飞船, 可以放大观看(左下角弹出窗口), 按下esc关闭. 
你可以点击飞船航线上某个点或者飞船本身, 然后点击一个方向. 表示飞船到此之后(或者现在)要转到这个角度. 转动是瞬间完成的. 之后地图右下角出现飞船缩略图. 点开之后你可以点击飞船的模块进行设定(见下面II-2的详细表述). 然后点击确定以设定更改. 然后飞船的航线可能会更新(如果你操作了发动机). 之后你需要在飞船界面里点击一个开始执行, 飞船才开始真正沿着航线飞行. 也可以点击停止, 飞船会瞬间丢失所有的航线和规划, 并匀速移动. 
如果你动作很慢, 在你选择的这个位置的命令设置完成前, 飞船就已经飞过该位置, 即使你设置的是延时指令(希望飞船到这里自己执行), 但是实际上此时飞船会在收到你的命令之后立即执行变动.
你可以缩放地图. 小地图上会出现一个小矩形以说明当前大屏幕显示的区域位于大地图的什么位置.
另外, 提供了画图工具. 可以方便的画线和擦除.
### 小地图
用蓝色和红色点表示飞船. 航线是不显示的. 核心指挥塔所在位置被用一更大的点表示. 
## II-2. 查看飞船
你可以点击飞船的零件以选择其行为. 具体有以下:
1. 发动机: 你可以调节其档位, 有前进1, 前进2, 前进3, 前进4四档. 实际上还有一档(关机)
2. 激光炮: 点击后, 会短暂弹出地图. 进入瞄准界面. 此时的敌方不仅有预测位置, 还有另一个绿色的预测位置, 表示敌方按照当前趋势, 激光炮接收指令开火, 到激光到达目标时, 目标可能所处的位置. 然后激光炮会射击(或设定计划向目标进行射击). 
3. 雷达: 点一下即可开机
4. 无人机舱: 点击后, 会弹出选项. 如果当前位于可采矿区域, 会弹出采矿选项. 然后可以采集. 另一个选项是进行组装. 会短暂弹出一个放大倍数较大的地图, 可以对小范围内的飞船进行模块改装. 若发动机正在运行, 无人机舱无法工作.
5. 能源系统: 点击之后, 该模块会自毁, 摧毁整个飞船. 在给有自爆任务的飞船下达正式命令前, 你需要多点一个确认.
6. 仓库: 无法交互. 只能鼠标悬停查看仓库储量.
7. 指挥塔: 无法交互. 
8. 综合支援平台: 可以建造模块, 同时消耗一些材料. 造好的模块会卡在平台内, 无法继续生产. 但是无人机可以将模块拿出来建造飞船, 同时让平台可以继续生产. 

在飞船的小窗口界面, 只能看到飞船有哪些零件. 
## 消息通知
只有那些最紧急的事情会被通知. 
这些是会被通知的事情:
1. 敌方飞船出现
2. 捕获到敌方雷达方位
3. 未计划的爆炸
4. 己方舰船被摧毁(包括自爆)

右下角小窗口的消息总是只有最新的一条. 点开之后可以在大屏幕查看所有的消息. 点击消息可以回到地图, 然后自动为地图上标记. 在消息界面删除消息会使得地图上的标记消失.

# III. 基本设定
类似传统rts游戏, 你需要采集资源, 建造军队, 然后打爆敌人的指挥部. 
## III-1. 建造军队
在传统的rts游戏里面, 你可以直接建造出一整个飞船, 或者一整个坦克, 等等. 但是在LCE中, 并没有这么简单. 
你需要先生产一种叫做"零件"的东西, 然后利用工程无人机模块(另一个零件)将零件组装起来, 从而形成具有各种功能的飞船.
| 零件名称 | 组装时间 | 所需材料 | 质量 | 功能简介 |
|:--:|:--:|:--:|:--:|:--:|
| 核心指挥塔 | - | - | 5mu | 游戏开始被安装在母舰上, 被摧毁就游戏结束 |
| 综合支援平台 | - | - | 30mu | 游戏开始被安装在母舰上, 唯一能生产零件的模块, 初始仅两台, 被摧毁就少一件
| 指挥塔 | 30s | 10mu | 5mu | 飞船必备模块, 不装就不能控制
| 发动机 | 30s | 10mu | 5mu | 推进飞船
| 能源模块 | 30s | 10mu | 5mu | 给飞船上其他零件提供必要的能源
| 激光炮 | 40s | 15mu | 8mu | 发射激光
| 仓库 | 10s | 6mu | 5mu | 装材料或燃料, 最多45mu |
| 雷达装置 | 100s | 70mu | 30mu | 开机后可以强行点亮一定范围内的敌人 |
| 工程无人机装置 | 60s | 40mu | 15mu | 可以挖矿和组装飞船 |

飞船组装的机制是特别浅显的. 只要安装了某个模块的飞船就一定会具备某个功能. 
为了简化设计, 飞船建造并不考虑物理规律. 你只要把各种零件连起来, 那就是个飞船. 每个零件都是个方形, 意味着你可以在发动机喷管后面装能源系统, 或者放个装满燃料的仓库, 而完全不用担心发动机会把它们点着, 或者导致飞船无法移动等. 
建造飞船并没有额外的需求. 并不是每个飞船都必须配备发动机. 甚至并非所有飞船都必须要有能源装置. 最简单的飞船就是一个指挥塔. 它几乎没有什么用, 但确实是个飞船. 反过来, 你可以安装一大堆零件, 形成一个功能齐全的庞然大物. 这可能导致推力不足或者能源不够. 这个时候你就可以安装好几个发动机和能源模块. 虽然这么做并不好(参见后面的"机制"部分)
## III-2. 采集资源
游戏地图由20*20=400个边长为1ls的区块构成. 光传播1ls的距离需要1s. 
游戏开始前, 系统会在第一象限随机生成地形. 具体来说, 某些区块会被替换为石头, 还有一些区块则被替换为星云. 当然, 大部分区块仍然是真空. 之后, 系统将第一象限所生成的地形对称到剩余三个象限. 
具备工程无人机模块而且具备有剩余空间的仓库的飞船抵达与石头区块左右或上下近邻(一个石头区块最多只有4个近邻)的区块时, 可以进行采集并获得材料. 每装备一个工程无人机模块, 速度增加0.5mu/s, 并且没有上限. 材料放进飞船的仓库模块中. 装满仓库后, 无法继续开采. 
具备工程无人机模块而且具备有剩余空间的仓库的飞船进入星云区块时, 可以采集燃料, 每装备一个工程无人机模块, 速度增加0.2mu/s, 没有上限. 
另外, 具备工程无人机模块的飞船可以调配一定范围内飞船的仓储. 比如从飞船A的仓库中取出多少材料或者燃料放进飞船B的仓库中. 无论调配多少数量的材料, 都是瞬间完成的. 然而, 这要求被调配飞船与进行调配操作的具备工程无人机的飞船的相对速度小于一个阈值. 
资源是无限量的, 不管怎么采集都不会枯竭. 
### III-3. 指挥
由于地图巨大无比, 连光传播都需要一定时间. 指令也是如此. 
指令被设计为往四面八方发射, 但是为了平衡性, 这并不会像雷达那样因此暴露母舰的方位. 
如果你把母舰苟在后方, 你给前线的飞船发消息可能就需要忍受好几秒的延迟. 可能让前线飞船在近战中比较吃亏. 相反, 如果你把母舰直接开到前线, 信号流畅了, 敌人一触即溃, 但是你的容错也会大大降低, 一旦母舰被流弹击中, 你就直接寄了. 

# IV. 机制简介
首先, 对于光速有限这个问题, 我需要做一些额外的解释. 
人类物理发展史上, 对于光的工作原理, 大致有3种观点. 
第一种是牛爵爷的弹道光. 光是粒子, 它和发光体的相对速度是光速. 由于牛顿物理尊崇绝对时空, 如果发光体相对空间有速度, 那光粒子就可以超过光速. 弹道光有一些显著的问题, 比如当观测很远的旋转速度很快的双星系统时候: 考虑两个恒星, 当任何一个恒星向着地球方向运动时, 光子速度叠加上恒星的旋转线速度, 使恒星的像快速被投射到地球. 而恒星想着反方向移动时, 光子速度就变得很慢, 需要很久才能到达地球. 所以如果时机合适, 可能会出现两个像同时到达地球的情况. 
第二种是基于以太的波动光. 光是波, 波的传播需要介质. 宇宙中遍布着这种介质叫做以太. 一束光发射出来, 无论发光体运动多快, 光波总是相对于空间背景板以光速传播. 相比牛爵爷那个体系稍微好一些, 因为至少现在先被发射的光总是能先被接收, 因果律是被保证的. 
第三种就是相对论. 上面那两种观点在经过实验时候都发现不对, 光速相对于所有惯性参考系都是一样大的才是目前普遍接受的事实. 然而, 由光速不变所带来的是非常麻烦的时间延缓. 这对于一个可能有PVP的游戏来说, 是极为致命的. 另外, 相对性挑战传统游戏设计中"地图+游戏刻"的设计, 过于困难.
因此, 游戏中的光被以第二种方式运算. 下列元素的运动或者扩散速度相对地图恒为光速, 与发射物的运动速度和状态无关.
- 激光原件发射的激光
- 雷达原件发射的雷达波
- 母舰发射的命令束
- 飞船自身发光(用于处理飞船直接发现飞船, 见下面的介绍)

## IV-1. 游戏刻
LCE中, 移动物体的判定是精确的, 这使得计算复杂. 所以, 一个游戏刻的时间是0.5s, 正常情况下(不正常情况: 你卡了), 一秒钟有两个游戏刻. 
### IV-1-1. 一刻内发生的事情
- 存档. 
- 遍历所有的飞船
  - 设遍历到的飞船是ship_i
  - 遍历所有与ship_i敌对的飞船
    - 设遍历到的飞船是ship_j
    - 检测ship_j是否被ship_i发现, 如果发现, ship_i观察到ship_j的像在哪里(详见IV-2)
  - 遍历所有的激光/碎片
    - 设遍历到的激光/碎片是damage_src_j
    - 检测ship_i是否与damage_src_j发生碰撞, 碰撞发生了几次, 碰撞发生的具体时刻是什么(详见IV-4)
    - 如果发生碰撞, 进行激光/碎片的伤害判定.
  - 真正执行飞船移动, 检测飞船是否飞进掩体里面. 
- 遍历所有的激光/碎片, 计算经过一整刻的时间与掩体的碰撞情况, 得到剩余角度. 
- 计划管理器工作
- 地图更新
### IV-1-2. 玩家操作和飞船操作
通常, 玩家的操作是为飞船添加"计划", 发射激光, 改变方向, 启动发动机, 这些实际上都是飞船操作. 通常, 玩家应当在飞船的航线上的许多点添加飞船操作的计划, 飞船飞行到这些位置自己就会执行这些操作. 
一刻之内, 我们通常希望飞船的加速度恒定, 没有新的激光或者碎片云产生. 但是如果飞船操作发生, 要是不加控制, 因为0.5s是巨大的间隔, 很有可能发生在一刻之间. 这时候如果按照飞船操作的点对刻进行分隔(形成两个刻), 就会导致问题非常复杂. 另外, 很多飞船的飞船操作可能发生地非常集中, 导致一秒钟之内游戏刻的数量达到一个无上限的巨大数值, 可能引发瞬间卡顿. 
因此对于这些操作, 我们强行将它们向后对齐到0.5s上. 具体来说. 如果发现一个飞船操作位于一个游戏刻的中间, 那就让它不要在原来的时刻发生, 而是推迟到这个游戏刻的终点. 这样, 游戏就可以均匀地处理游戏的进程. 
玩家操作却更加复杂. 参见下面的IV-3, 为了容忍更大的网络延迟, 玩家操作和飞船操作并不是完全实时的. 
- 母舰控制器会在接收到玩家"发送命令"操作之后的0.5s才发出信号.
- 母舰上其他零件也得在收到玩家对母舰下达的直接命令之后的0.5s才发送信号. 
在下面的机制介绍里面, 会讲解为什么这样的设计可以容忍至多500ms的网络延迟.

## IV-2. 视野与隐蔽
### IV-2-1. 被发现距离
每个飞船有一个重要的参数: 被发现距离. 当有敌方飞船处于以你的某个飞船为圆心, 被发现距离为半径的圆中, 而且飞船与敌方飞船之间的连线没有被掩体遮挡的时候, 你的飞船就会"被发现". 显然, 被发现距离越大, 飞船的隐蔽就越糟糕. 
你无法知道你的哪些飞船被发现了, 但是你可以观察到哪些敌方飞船被发现, 因为它们会出现在小地图上. 
### IV-2-2. 隐蔽计算
被发现距离取决于下面几个因素: 
- 飞船的零件个数
- 飞船各模块的使用情况
- 环境

飞船的被发现距离被这样计算:
1. 基础隐蔽值=零件个数*0.25
2. 之后, 每当有一个发动机开机, 这个隐蔽值增加0.4*推进等级. 例如, 一台前进IV的发动机增加1.6, 两台前进III的发动机增加2.4. 
3. 每个激光炮开火会短暂为飞船增加0.2的隐蔽值. 
4. 另外, 如果飞船被击中但是并没有被摧毁, 会瞬间增加2的隐蔽值, 持续1s
5. 基础被发现距离是基础隐蔽值的平方, 单位为ls. 
6. 最终发现距离=基础被发现距离*环境系数. 其中, 对于真空, 这个系数是1. 对于星云区域, 这个系数是0.5

例如: 一台单发动机+单能源装置+单仓库飞船, 全力加速时, 其基础隐蔽值达到2.6, 若处于真空中, 被发现距离达到6.76ls. 在边长仅20ls的房间中, 若地形较为开阔, 就比较容易被发现. 
### IV-2-3. 被发现
对于每个飞船, 在一游戏刻之内, 需要判定它是否被任何一个敌方飞船发现. 
首先要计算当前飞船的基础隐蔽值, 记为d_observed.
然后称回溯时间t_back=min(d_observed/c, 飞船存在时间)
然后将时间回档至当前游戏刻-t_back. 如果这个时刻并不正好处于游戏刻边界, 那向前对齐. 
对于此飞船和选定的敌方飞船, 令此飞船的坐标(关于t的变化函数)是P_observed(t), 敌方飞船的坐标是P_enemy(t).
解方程: |P_observed(t)-P_enemy(当前时刻)|=c*(当前时刻-t)
如果在区间[t_back, 当前时刻]中发现解ans_t, 则认为有被敌方飞船发现的可能性. 敌方飞船在当前游戏刻所看到的飞船"像"位于P_observed(t_ans), 然后会检测这个位置与敌方飞船当前所在位置的连线中间是否与任何一个掩体相交, 如果没有相交, 说明飞船被发现, 位置将会被敌方飞船记录并发送回它的母舰. 否则, 并没有被发现, 检测下一个飞船. 

## IV-3. UI界面和网络
### IV-3-1. UI
UI本身是50帧的, 但是地图的加载速度仍然只有2帧(一刻0.5s). 所以可以流畅地拖动和缩放地图, 到处切换窗口, 但是飞船的移动看起来一卡一卡的. 这是无奈的选择. 因为独特的机制, 一刻的计算量较大, 我们必须给cpu足够的时间, 0.5s的一整个游戏刻的时间都给它计算, 而不能假设cpu能够在很快的时间内算出1刻之后地图的行为, 然后用线性差值画出流畅的飞船飞行轨迹. 
地图用链表的形式存储飞船, 碎片和激光. 每帧渲染的时候, 会遍历所有元素, 然后显示其中的友方单位. 
### IV-3-2. 网络
为了让大家方便快乐游玩, 游戏不借助一个服务器就可以游玩. 联机的双方只需要直接连接(局域网或者穿透, 这较为技术性, 先不管), 然后双方就可以一起玩, 而且双方电脑扮演的功能均等, 并不会由其中一方担任更多的算力. 
假设现在A, B要进行联机. 现在系统会在A, B上按照种子生成一样的地图, 以后A, B所观察到的地图均为分别在他们自己的电脑上计算的. 
当A或B其中的一人进行操作后, 这个操作会立即发送给对方电脑. 然后对方电脑上也同步做出这样子的操作(就好像一个电脑上同时有两个人在玩), 只不过在对方看来, 这个操作是隐藏的. 由于网络有或多或少的延迟, 一旦操作不同步, 问题就会很严重. 因此根据前面IV-1所说, 对于玩家操作, 我们有高明的设计: 延迟0.5s. 
不妨设A现在做了一个操作, 现在这个操作在A的电脑上会延迟0.5s发生. 由于信号不太好, 有200ms的延迟, 所以这个操作在A进行操作之后的0.2s, B的电脑才收到这个操作. 然而, B的电脑通过解析这个发送过来的包的时间信息, 发现这个操作是在0.2s之前发生的, 所以B的电脑上仅仅延迟0.3s(而不是也延迟0.5s)就发生了. 
具体的时间顺序是这样子:
- 0s: A操作
- 0.2s: B接收到A的操作
- 0.5s: A, B电脑同时进行这个操作

这个小小的延迟就保证了网络信号不佳的情况下, 也能流畅地玩耍. 但是当延迟更大的时候, 这种方法就不靠谱了. 
对于这样子的问题, 我们决定不处理. 如果网络信号不佳(发现一个操作的发送时间比当前时刻要晚超过500ms), 那就直接结束游戏. 

另外, 为了处理丢包的问题, 我们也让双方时不时向对方发送一个"我还活着"的消息. 这个消息同时包含了双方"看对方操作的次数". 比如, A自己看到自己操作了100次, 但是B告诉它, 只接收到A的99次操作, 说明有操作被传丢了. 因为这种情况也比较少, 对此我们选择不处理, 直接也结束游戏. 如果很久都没有看到对方发送这样子的消息, 可能说明自己或对方网络不好(可能已经自动游戏结束), 会自动也结束游戏.

这样子暴力地直接结束游戏的处理显然太保守了, 以后我们肯定有更好的办法, 但这并不是重点. 

## IV-4. 碰撞检测的详细解释
碰撞检测是这个游戏的特色. 因为它实在是太复杂了, 一秒两帧只是妥协. 但是这样高明的算法并不是因为帧数太低而变得不准. 
### IV-4-1. 飞船, 激光, 碎片和掩体
- 飞船: 被看作是一个点. 没有大小. 
- 激光: 是一个半径匀速扩大的圆上的一小段圆弧. 
  - 圆心: 飞船发射激光时所在位置, 固定不动.
  - 半径: t*发射时间
  - 角度范围: 指向飞船发射方向, 顺时针和逆时针各0.5毫角秒. 如果其中有些部分曾经被掩体遮挡, 这些部分会永久消失. 
- 碎片: 一个半径匀速扩大, 并且圆心也在匀速直线运动的圆.
  - 圆心: 碎片产生时所在位置. 运动速度为碎片产生时瞬间的速度. 
  - 半径: t*扩散速度
  - 角度范围: 初始为整圆. 如果其中有些部分曾经被掩体遮挡, 这些部分会永久消失. 
- 掩体: 一些地图中的正方形. 
### IV-4-2. 飞船与激光/碎片的碰撞
很显然, 激光和碎片非常相似. 它们的圆心都是匀速移动的(激光的圆心始终以0的速度匀速移动). 半径也是匀速扩大的(激光和碎片扩散大小不一样而已). 与掩体的交互行为也完全一致. 我们不妨只讨论碎片与飞船碰撞的行为. 
我们需要一个函数, 给定一个飞船对象和一个碎片对象, 它返回在指定的时间范围内, 发生碰撞的所有时刻(如果可能发生多次碰撞, 需要返回多个). 
这个函数的工作原理简单来说就是两个步骤:
- 假设碎片是完整的, 然后解方程算出发生碰撞的时机(只要|P_ship(t)-O_debris(t)|=r_debris(t))
- 然后检测一下每个碰撞发生的时刻, 碎片还剩下多少的角度范围(通过下面IV-4-3的介绍). 如果发现发生碰撞的时刻, P_ship相对O_debris的角度位于尚未被掩体遮挡的角度中, 则确实发生了一次碰撞. 
### IV-4-3. 掩体与激光/碎片的碰撞
实际上只需要实现一个函数, 给定一个掩体对象和碎片对象, 然后它返回经过指定的时间, 碎片对象被遮挡掉的角度区间(如果区间很多, 需要返回多个). 
对于IV-4-2中, 判断每个碰撞时刻, 碰撞发生的位置是否处于被遮挡角度中. 只需将碰撞时刻到当前游戏刻的起点的时间差告诉此函数, 然后将碎片与每个掩体通过此函数处理, 即可知道碰撞时刻的碎片剩余角度范围, 从而得知碰撞是否真实发生. 
### IV-4-4. 掩体与飞船的碰撞
飞船只要飞进掩体里面, 直接死亡. 

## IV-5. 计划管理器
计划管理器存储着所有的飞船操作(比如发动机档位变化, 转向, 激光发射), 还有爆炸. 在运行到正确的游戏刻时, 计划管理器会真正执行这些操作. 计划管理器就是无上的神明, 一切的操作都必须经由其手. 
当飞船发现敌方飞船时, 它会将"传送消息"的计划交给计划管理器, 在下一刻的起点执行.
当飞船爆炸时, 会将"爆炸"的计划交给计划管理器, 在下一刻的起点执行. 
当飞船接收到母舰的命令时, 会将命令或命令计划统统交给计划管理器. 对于那种立即执行的命令, 计划管理器将其放到下一刻的起点执行. 对于命令计划(让飞船到航线上某个位置执行特定的命令), 计划管理器计算出每个命令的精确执行时间, 然后将其向后对齐到各个游戏刻的终点. 
母舰接收到飞船的消息时(比如观察到敌方飞船, 观察到爆炸等), 也要告诉计划管理器. 计划管理器会在下一刻的起点在ui的地图上进行渲染. 
### IV-5-1. 存储结构
计划管理器是一个哈希表. 其键就是每个飞船的身份信息, 其值则是一个双向链表, 装满这个飞船的全部操作. 
每一刻, 计划管理器都可能更新许多次. 如果当前游戏刻当中有飞船操作, 那就更新这个飞船的链表, 并且把哈希表的当前飞船的值设定为这个飞船操作所在的链表节点. 

## IV-6. 通讯和监听
正常来说. 友方飞船之间是不进行"观测"活动的. 但是有些时候友方飞船需要互相进行通讯. 由于无线电波的行为和飞船因为发出光而被探测的行为非常类似, 此处直接借用视野与隐蔽部分的代码, 但是机制略有区别.
### IV-6-1. 监听友军
现在, 在进行视野与隐蔽计算的时候, 飞船不仅会尝试发现敌军的位置, 也会遍历一个叫做"监听的友军"的列表, 当然敌舰的遍历与友方的遍历是分开的. 
监听友军与发现敌军有大量的相同之处:
1. 使用同一个函数
2. 都返回"观察到"的飞船的过去的像的位置, 已经"观察到"的飞船所处的时刻. 
然而, 监听友军时, 发现距离被设定为无限. 这使得无论位于什么位置, 都可以"发现"友军.
并且, 当监听到友军的信息之后, 飞船会立马将此友军飞船移除"监听的友军"列表.
当在外飞船发出消息(比如: 观察到敌舰)时候, 母舰将其添加到监听列表中. 然后直到观测到该飞船, 这个飞船发送的消息才会被处理, 例如, 将发现的敌军位置渲染到屏幕上等. 同理, 当母舰发送消息时, 将接收消息的飞船将母舰添加到监听列表中. 然后直到该飞船观测到母舰, 飞船才执行母舰的命令(添加到计划管理器中).
### IV-6-2. 命令
母舰对在外舰艇发送的消息格式是计划. 而在外监听对母舰发送的消息则是发现和发现类型(爆炸, 敌方飞船), 还有亡语(只有飞船阵亡才会发送). 消息被暂存在监听友军列表中, 与友军飞船的指针同级存储. 当消息送达, 整个节点就被释放. 
